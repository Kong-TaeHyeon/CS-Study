## 네트워크

네트워크란 노드(node)와 링크(link)가 서로 연결되어 있거나 연결되어 있으며 리소스를 공유하는 집합을 의미합니다.

- 노드 : 서버, 라우터, 스위치 등 네트워크 장비
- 링크 : 유선 또는 무선을 의미

### 처리량과 지연 시간

#### 처리량

처리량(throughput)이란 링크를 통해 전달되는 단위 시간당 데이터양을 의미합니다.

#### 지연 시간

지연 시간(latency)이란 요청이 처리되는 시간을 말하며, 어떤 메시지가 두 장치 사이를 왕복하는 데 걸린 시간을 의미합니다.

- '좋은' 네트워크란 높은 처리량을 통해 **단위 시간당 많은 데이터양을 전달함**과 동시에, **낮은 지연시간을 통해 각 요청이 빠르게 처리**되어야 합니다.

### 네트워크 토폴로지

네트워크 토폴로지란, 노드와 링크가 어떻게 배치되어 있는지에 대한 방식이자 연결 형태를 의미합니다.

#### 트리 토폴로지

<image src="./image/tree-topology.png" width = 300 height = 200 />

- 확장성이 우수하며, 관리가 효율적입니다.
- 상위 노드에 의존적이며, 부모 노드에 장애가 발생시, 자식 노드에게도 영향이 있습니다.

#### 버스 토폴로지

<image src="./image/bus-topology.png" width = 300 height = 200 />

- 설치가 간단하며 비용이 저렴합니다.
- 한 노드의 고장이 전체에 영향을 줄 수 있습니다.
- 악의적인 노드가 추가될 경우 스위칭 기능을 마비시키거나 속일 수 있게되는 스푸핑 공격에 취약합니다.

#### 스타 토폴로지

<image src="./image/star-topology.png" width = 300 height = 200 />

하나의 중앙 허브(스위치)에 모든 노드가 개별 연결됩니다.

- 노드 추가 및 에러 탐지가 편이합니다.
- 중앙 허브를 제외한 노드 장애 발생 시, 타 노드에 영향을 주지 않습니다.
- 중앙 허브 고장 시 전체 마비.

#### 메시 토폴로지

<image src="./image/mesh-topology.png" width = 300 height = 200 />

- 높은 안정성, 트래픽 분산 처리가 가능
- 설치가 복잡하고 높은 비용

### TCP/IP 4계층 모델

<image src="./image/network-layer.png" width = 300 height = 200 />

#### 애플리케이션 계층

애플리케이션 계층은 FTP, HTTP, SSH, SMTP, DNS 등 응용 프로그램이 사용되는 프로토콜 계층이며 웹 서비스, 이메일 등 **서비스를 실질적으로 사람들에게 제공하는 계층**입니다.

- FTP : 파일 전송 프로토콜
- SSH : 원격 시스템에 접속하기 위한 프로토콜 (암호화, 인증 보장)
- HTTP : 웹 브라우저와 웹서버 사이의 통신을 위한 프로토콜
- SMTP : 메일 전송을 위한 프로토콜
- DNS : 도메인 이름과 IP 주소를 맵핑해주기 위한 서버

#### 전송 계층

전송계층은 송신자와 수신자를 연결하는 통신 서비스를 제공하며 연결 지향 데이터 스트림 지원, 신뢰성, 흐름 제어를 제공할 수 있으며 프로세스와 프로세스간 데이터 전달을 지원합니다.

**가상회선 패킷 교환 방식**  
가상회선 패킷 교환 방식은 각 패킷에 가상회선 식별자가 포함되며 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 '순서'에 맞게 도착하는 방식입니다. TCP는 이러한 교환 방식을 사용하여 데이터를 전달합니다.

- 3-Way Handshake 를 통한 통신 시작.
  - **SYN 단계** : 클라이언트는 서버에 클라이언트의 ISN을 담아 SYN을 보냅니다. ISN은 새로운 TCP 연결의 첫 번째 패킷에 할당된 임의의 시퀸스 번호를 말합니다.
  - **SYN + ACK 단계** : 서버는 클라이언트의 SYN을 수신하고 서버의 ISN을 보내며 승인번호로 클라이언트의 ISN + 1을 전송합니다.
  - **ACK 단계** : 클라이언트는 서버의 ISN + 1한 값을 승인번호를 담아 ACK를 서버에 보냅니다.
- 4-way Handshake 를 통한 통신 종료.
  - 먼저 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보냅니다. 그리고 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다립니다.
  - 서버는 클라이언트로 ACK 세그먼트를 보내며, CLOSE_WAIT 상태에 들어갑니다. 클라이언트가 해당 세그먼트를 수신하면 FIN_WAIT_2 상태에 들어갑니다.
  - 서버는 ACK를 보내고 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보냅니다.
  - 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내며, 서버는 CLOSED 상태가 됩니다. 이후 클라이언트는 일정 시간 대기 후, 연결이 닫히면 클라이언트와 서버 사이의 연결 자원이 해제됩니다.

**왜 클라이언트는 TIME_WAIT 상태로 대기하는걸까?**

1. 지연 패킷으로 인해 뒤늦게 패킷이 클라이언트에게 도달하게 될 경우를 대비하기 위해서. 대기하지 않고 같은 포트 번호로 새로운 연결이 생성되어 이전 연결에 대한 데이터가 수신되는 문제가 발생할 것입니다.
2. 마지막 서버에게 전송한 ACK 세그먼트가 제대로 수신되지 않는다면, 서버는 다시 재전송을 요청할 것입니다. 그러나 TIME_WAIT이 아닌 CLOSED 상태라면 클라이언트는 이를 수신하지 못하여 서버 측 연결은 열려있는 상태(LAST_ACK)가 될 것입니다.

**데이터그램 패킷 교환 방식**  
데이터그램 패킷 교환 방식에서는 각 패킷이 독립적으로 전달되어, 하나의 데이터를 구성하는 여러 패킷은 서로 다른 순서로 도착할 수 있으며 이를 상위 레이어에서 처리하여 데이터를 구성하게 됩니다.

#### 인터넷 계층

인터넷 계층은 장치로부터 받은 네트워크 패킷을 IP 주소로 지정된 목적지로 전송하기 위해 사용되는 계층입니다. 패킷을 수신해야 할 상대의 주소를 지정하여 데이터를 전달합니다. 상대방이 패킷을 제대로 수신했는지를 보장하지 않는 비연결형적인 특성을 가지고 있습니다.

#### 링크 계층

링크 계층은 실질적으로 데이터를 전달하며 장치 간에 신호를 주고받는 '규칙'을 정하는 계층입니다. (Physical Layer + DataLink Layer)

#### 계층 간 데이터 송수신 과정

<image src="./image/data-transport.png" height = 200 />

애플리케이션 계층에서 전송 계층으로 그리고 전송 계층에서 인터넷 계층, 최종적으로는 링크 계층으로 캡슐화가 진행되며, 이후 수신측에서는 비캡슐화를 통해 다시 온전한 데이터를 얻게됩니다.

### IP 주소

#### ARP

IP 주소 기반으로 통신한다고 알고 있지만, IP 주소에서 ARP를 통해 MAC 주소를 찾아 MAC 주소를 기반으로 통신합니다.

ARP(Address Resolution Protocol)란 IP 주소로부터 MAC 주소를 구하는 IP와 MAC 주소의 다리 역할을 하는 프로토콜입니다.

ARP를 통해 가상 주소인 IP 주소를 실제 주소인 MAC 주소로 변환합니다. 이와 반대로 RARP를 통해 MAC 주소를 IP 주소로 변환하기도 합니다.

---

**A가 B에게 데이터를 전송하고자 하는 상황**

<image src="./image/arp-1.png" height = 200 />

A는 서브넷 마스크를 통해 B가 같은 네트워크가 아닌 서로 다른 네트워크라는 것을 인지한다. 따라서, 라우터로 패킷을 전달한다.

이때, 라우터의 IP 주소는 알지만 MAC 주소를 모르기 때문에 브로드캐스트를 통해 같은 서브넷의 기기들에게 질문한다. (ARP)

이후, 라우터는 해당 브로드캐스트 질의에 대해 A에게 유니캐스트(1:1)를 통해 자신의 MAC 주소를 전달한다.

따라서 A는 라우터에게 목적지 IP 주소는 B의 IP, 목적지 MAC 주소는 라우터 주소로 설정하여 패킷을 전달한다.

수신한 라우터는 라우팅 테이블을 통해 B에게 패킷을 전달한다.

---

#### DHCP

DHCP(Dynamic Host Configuration Protocol)는 IP를 자동으로 할당하기 위한 네트워크 관리 프로토콜입니다. 이를 통해 네트워크 장치는 IP 주소를 수동으로 설정할 필요 없이 인터넷에 접속할 때마다 자동으로 IP 주소를 할당할 수 있습니다. 따라서 인터넷을 사용하지 않는 장치는 IP 주소를 할당받지 않으므로, **동일한 IP 주소를 재사용할 수 있는 장점**이 있습니다.

#### NAT

NAT(Network Address Translation)는 패킷이 라우팅 장치를 통해 전송되는 동안 패킷의 IP 주소 정보를 수정하여 IP 주소를 다른 주소로 매핑하는 방법입니다.
이 방식을 통해, 서브넷의 여러 장치들이 동일한 공인 IP를 사용하여 인터넷에 연결될 수 있습니다. (ex : 공유기)

**그렇다면 외부에서는 어떻게 구분할까?**  
이는 **포트 기반으로 구분할 수 있습니다.**. 공인 IP주소가 10.0.0.2로 사용하더라도 각 소켓의 포트는 다르기 때문입니다. 따라서 10.0.0.2:1000, 10.0.0.2:1001 처럼 동일한 서브넷의 장치들의 소켓을 구분할 수 있게 됩니다.

### HTTP

#### HTTP/1.0

<image src="./image/http-1.0.png" height = 300/>

HTTP/1.0 은 기본적으로 하나의 연결당 하나의 요청을 처리하도록 설계되었습니다. 따라서 요청의 횟수가 늘어날수록 TCP의 3-Way Handshake (RTT) 과정이 발생하게 됩니다.

**이를 위한 해법**  
매번 연결할 때마다 RTT가 증가하니, 한번의 요청에 많은 데이터를 받기 위한 방법이 등장하였습니다.

- 이미지 스플리팅
  - 많은 이미지를 다운로드 받게 되면 과부하가 걸리기 때문에 합쳐 있는 하나의 이미지를 다운로드 받고, 이를 기반으로 background-image 의 position을 이용.
- 코드 압축
  - 코드를 압축해서 개행 문자, 빈칸 등을 없애서 코드의 크기를 최소화하는 방법.
- BASE 64 인코딩
  - 이미지 파일을 64진법으로 이루어진 문자열로 인코딩하는 방식. 이를 통해 별도의 이미지 파일 요청없이 하나의 HTML에 이미지를 포함할 수 있게됩니다. 다만 실제 이미지 파일 대비 용량이 증가하는 단점이 존재합니다.

---

#### HTTP/1.1

<image src="./image/http-1.1.png" height = 300/>

HTTP/1.0 의 단점인 매 요청마다 발생하는 3-Way Handshake 를 줄이기 위해, 한번 생성된 TCP 연결을 유지하여 재사용합니다. `(Connection : Keep-Alive)`

또한 `Pipelining` 이라는 기법을 사용하여, 여러 요청을 먼저 전송한 뒤 응답을 받을 수 있게 됩니다.

그러나, 앞선 요청의 지연으로 인해 이후 요청들 역시 지연될 수 있는 문제가 존재합니다. (`Hole Of Line Blocking`)

<image src="./image/http-1.1-hol.png" height = 300/>

그림과 같이 먼저 전송한 요청1이 지연된다면, 이후 요청한 요청2,3은 요청1이 처리될 때까지 대기하게 되는 문제가 발생하게 됩니다.

---

#### HTTP/2.0

**멀티 플렉싱**  
하나의 요청을 프레임 단위로 잘개 쪼갠 뒤, 각 프레임의 대한 요청을 병렬로 처리합니다. 이러한 요청을 스트림 단위로 구분하여, 앞선 HTTP/1.1 에서 발생하는 HOL 문제를 방지할 수 있게 됩니다.

<image src="./image/http-2.0.png"/>

그림과 같이 하나의 TCP Connection 에서 여러 요청/응답을 프레임이라는 단위로 잘개 쪼게어 순서와 관계없이 전송할 수 있게 됩니다. 이러한 요청/응답은 스트림ID로 구분되며, 각 요청에 대한 응답은 해당 스트림ID를 기준으로 조립되게 됩니다.

프레임이라는 단위가 작기 때문에 기존 HTTP/1.1에서 발생하였던 하나의 요청으로 인한 지연이 발생하지 않게 됩니다.

**헤더 압축**  
이전의 HTTP/1.1에서는 헤더의 크기가 커 요청과 응답에 담긴 데이터가 커진다는 문제가 있었습니다. 따라서 이를 해결하고자 HTTP/2.0에서는 허프만 코딩 압축 알고리즘을 사용하여 헤더 압축을 진행합니다.

- 허프만 코딩 : 문자열을 문자 단위로 쪼개어 높은 빈도 수의 문자에는 낮은 비트를 할당하고, 낮은 빈도의 문자에는 높은 빈도를 할당하여 전체 데이터에 필요한 총 비트 수를 줄이는 방식.

---
